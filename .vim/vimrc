" Quita el modo compatible con vi
set nocompatible

" ######## PLUGINS ########
packadd minpac
call minpac#init()
command! Pack call minpac#update()

" Edición de texto.
call minpac#add("tpope/vim-repeat")
call minpac#add("tpope/vim-surround")
call minpac#add("godlygeek/tabular")
call minpac#add("tpope/vim-unimpaired")
call minpac#add("inkarkat/vim-ReplaceWithRegister")
call minpac#add("tommcdo/vim-exchange")

" Navegación por conjuntos de texto.
call minpac#add("kana/vim-textobj-user")
call minpac#add("kana/vim-textobj-lastpat")
call minpac#add("kana/vim-textobj-indent")
call minpac#add("kana/vim-textobj-entire")
call minpac#add("kana/vim-textobj-line")
call minpac#add("wellle/targets.vim")
call minpac#add("lucapette/vim-textobj-underscore")
call minpac#add("kana/vim-smartword")
call minpac#add("nelstrom/vim-visual-star-search")

" Ruby.
call minpac#add("vim-ruby/vim-ruby")
call minpac#add("tpope/vim-projectionist")
call minpac#add("tpope/vim-rake")
call minpac#add("tpope/vim-bundler")
call minpac#add("tpope/vim-rails")
call minpac#add("tpope/vim-endwise")
call minpac#add("nelstrom/vim-textobj-rubyblock")

" Git.
call minpac#add("gregsexton/gitv")
call minpac#add("tpope/vim-fugitive")

" Otros lenguages.
call minpac#add("thomd/vim-jasmine")
call minpac#add("elixir-editors/vim-elixir")

" Apoyo a varios lenguajes.
call minpac#add("tomtom/tcomment_vim")
call minpac#add("scrooloose/syntastic")
call minpac#add("AndrewRadev/splitjoin.vim")
call minpac#add("AndrewRadev/switch.vim")

" Integración con la shell
call minpac#add("mhinz/vim-grepper")
call minpac#add("epeli/slimux")
call minpac#add("junegunn/fzf")
call minpac#add("junegunn/fzf.vim")
call minpac#add("janko/vim-test")

" Aspecto.
call minpac#add("Lokaltog/vim-powerline")
call minpac#add("junegunn/goyo.vim")

" Sustituciones.
call minpac#add("tpope/vim-abolish")

" Autocompletado
call minpac#add("neoclide/coc.nvim", { "branch": "release"})

" Varios.
call minpac#add("mbbill/undotree")
call minpac#add("qpkorr/vim-bufkill")
call minpac#add("tpope/vim-rsi")

" Aumenta el poder del % para if-else-end y más cosas (activa por defecto).
runtime macros/matchit.vim


" ######## ENTORNO ########
set shell=/bin/zsh

" Quita la línea extra al final del fichero que añade vim
set noeol
set binary

" Elimina el retardo al salir del modo inserción.
set noesckeys

" Muerte a los números octales.
set nrformats=hex

" La tecla leader por defecto es la \, que está muy lejos.
let mapleader = ","
noremap \ ,

" Por defecto sólo se recuerdan las últimas 20 órdenes. Subimos.
set history=10000

" Conserva historial de cambios al salir
set undofile
set undodir=~/.vim/undo
augroup vimrc
  autocmd!
  autocmd BufWritePre /tmp/* setlocal noundofile
augroup END

" No expandir a la primera coincidencia de orden automáticamente al dar
" al tabulador, sino listar las posibles
" las opciones que más me gustan son list:longest y list:full
set wildmode=list:longest,full

" ###### ASPECTO ######
if has("gui_running")
  " Elimina las barras de edición y los menús
  set guioptions-=m
  set guioptions-=T
  " Quita el parpadeo del cursor.
  set guicursor+=a:blinkon0
endif

" Tema propio, basado en nuvola.
colorscheme autumnriver

" Resaltados de sintaxis en función del tipo de fichero
syntax on
filetype off
filetype plugin indent on
" Sintaxis con espacios
autocmd FileType * setlocal ts=2 sts=2 sw=2 tw=0 expandtab
autocmd FileType gitcommit set tw=72

" Incluye el título en la ventana (gvim lo hace automáticamente)
set title
" Incluye siempre la ruta del fichero que se edita
set laststatus=2

" Cambiar el cursor en Konsole, con o sin tmux.
if exists('$TMUX')
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\007\<Esc>\\"
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\007\<Esc>\\"
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" Powerline
set noshowmode
let g:Powerline_stl_path_style = "short"
" Requiere parchear una tipografía con powerline fontpatcher
let g:Powerline_symbols = "fancy"

" Muestra el número de línea
set number
" Muestra el número de línea al final de la pantalla (ya estaba activo por
" defecto)
set ruler
" Por defecto, no contrae las líneas cuando carga un nuevo buffer
set nofoldenable


" ####### COPIAR Y PEGAR ######
" Autoindentado al pegar
nnoremap <silent> <Plug>PasteIndent p=`]<C-o> :call repeat#set("\<Plug>PasteIndent", v:count)<CR>
nmap p <Plug>PasteIndent
nnoremap <silent> <Plug>PasteAbove P=`]<C-o> :call repeat#set("\<Plug>PasteAbove")<CR>
nmap P <Plug>PasteAbove
" Pegar a y del sistema con AltGr+c y AltGr+v
vm { "+y
nm } "+gp
inoremap <C-r> <C-r><C-p>
" Pegar texto copiado en la línea de órdenes
cm <C-v> <C-r>"
im <C-v> <C-r>"

" Seleccionar el último texto copiado o pegado
nm gV `[v`]


" ###### PASAR DE UN MODO A OTRO ######
" Pasar más fácilmente a la línea de órdenes
nnoremap <Space> :
" Salir con la ñ de modo visual.
vm ñ <C-c>
" Y lo mismo en la línea de órdenes
cm ñ <C-c>
" C-c genera InsertLeave
inoremap <C-c> <Esc>

" ###### ABRIR, CERRAR Y GUARDAR ######
" Grabar archivo tanto en modo normal como en edición
nm ñ :w<CR>
" Salir del buffer actual, dejando la ventana usando bufkill
nm <Leader>z :BD<CR>
" Cierra la ventana.
nm <Leader>d :q<CR>
nm <Leader>x :x<CR>
"Dejar sólo el buffer actual
nm <Leader>o :on<CR>
" Abrir ficheros
nm <Leader>v :vsplit<CR>
"
" Recupera la línea del fichero en la que estaba la última vez que se editó
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
" Permite quitar el buffer de la ventana aunque no se haya grabado
set hidden
" Directorios donde se guardan todos los archivos swp y backups
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp

" Cerrar quickfix y loclist
autocmd FileType qf nm <buffer> q :q<CR>
nm <Leader>bl :lclose<CR>

" ###### NAVEGACIÓN ######
" Navegación por líneas.
" 0 es más fácil de teclear que ^ en teclado español, así que intercambio sus
" funciones
nnoremap 0 ^
nnoremap ^ 0
vnoremap 0 ^
vnoremap ^ 0

" Marcas
" ' es más útil que ` porque te lleva también a la columna, no sólo a la línea
nnoremap ' `
nnoremap ` '

" Navegación entre ventanas
nnoremap <tab> <C-w>w
" Abrir ventanas a la derecha en vez de a la izquierda
" y abajo en vez de arriba
set splitright
set splitbelow
" Editar el buffer que se editaba justo antes de cambiar al actual
nm <Leader><Leader> <C-^>

" Saltos
" Vim no distinque entre Ctrl-i y TAB, y uso tab para cambiar de ventana
nnoremap <C-c> <C-i>
" <C-o> lo coge tmux
nnoremap <C-w> <C-o>
nnoremap <Leader>w <C-w>

" C-] en algunos terminales se interpreta como C-+ y además es difícil de
" teclear.
nm <Leader><Space> <C-]>

" Si el nombre del fichero incluye número de línea, vamos a esa línea con gf
set isfname-=:
nnoremap gf gF
nnoremap gF gf

" ###### BÚSQUEDAS ######
" Resalta el primer resultado de la búsqueda según tecleas
set incsearch
" Resalta todas las coincidencias de la búsqueda
set hlsearch
" Quita el resaltado de las coincidencias (lo vuelve a poner en la siguiente
" búsqueda)
nm ç :nohlsearch<CR>
" No diferencia buscar mayúsculas y minúsculas salvo que se escriba alguna
" mayúscula set ignorecase
set ignorecase
set smartcase
" Busca literal por defecto.
nnoremap / /\V

" ##### SUSTITUCIONES #####
" Repetir la última sustutición conserva los modificadores (:help &)
nnoremap & :&&<CR>
vnoremap & :&&<CR>


" ##### LÍNEA DE ÓRDENES #####
" Buscar el historial de forma incremental sin las flechas
cnoremap <C-k> <Up>
cnoremap <C-j> <Down>


" #### INTRODUCIR CARACTERES Y LÍNEAS EN MODO NORMAL ####
" Introducir un carácter antes/después del cursor y volver a modo normal
function! RepeatChar(char, count)
  return repeat(a:char, a:count)
endfunction
nm s :<C-u>exec "normal i".RepeatChar(nr2char(getchar()), v:count1)<CR>
nm S :<C-u>exec "normal a".RepeatChar(nr2char(getchar()), v:count1)<CR>

" Introducir líneas en blanco antes y después de la actual en modo normal
nmap <C-k> [<Space>
nmap <C-j> ]<Space>

" o y O no añaden comentario cuando se usan en línea con comentario
autocmd FileType * setlocal formatoptions-=o


" ######### RAILS #########
nm <Leader>em :Emodel<Space>
nm <Leader>ec :Econtroller<Space>
nm <Leader>ev :Eview<Space>
nm <Leader>eh :Ehelper<Space>
nm <Leader>ej :Ejavascript<Space>
nm <Leader>ed :Edecorator<Space>
nm <Leader>ep :Epdf<Space>
nm <Leader>ea :A<cr>
nm <Leader>er :R<cr>
nm <Leader>el :Elib<Space>
nm <Leader>es :Espec<Space>
nm <Leader>esm :Espec models/
nm <Leader>esf :Espec features/
nm <Leader>ess :Espec system/
nm <Leader>esl :Espec lib/
nm <Leader>esc :Espec controllers/
nm <Leader>esv :Espec views/
nm <Leader>ef :Efactory<Space>
nm <Leader>ee :Eenvironment<Space>
nm <Leader>ei :Einitializer<Space>
nm <Leader>et :Elocale<Space>
" Atajos para tipos de ficheros.
let g:rails_projections = {
  \ "app/decorators/*_decorator.rb": { "command": "decorator" },
  \ "app/form_builders/*_form_builder.rb": { "command": "builder" },
  \ "app/pdfs/*.rb": { "command": "pdf" },
  \ "app/cells/*_cell.rb": { "command": "cell" },
  \ "app/cells/*.haml": { "command": "cview" },
  \ "spec/javascripts/fixtures/*.html": { "command": "jfixtures" },
  \ "spec/factories/*.rb": {"command": "factory"},
  \ "spec/requests/support/*.rb": {"command": "support"}}


" ######## GIT ########
" atajos para Git
nm <Leader>gs :Gstatus<cr>
nm <Leader>gc :Gcommit<cr>
nm <Leader>ga :Gcommit --amend<cr>
nm <Leader>gw :Gwrite<cr>
nm <Leader>gr :Gread<cr>
nm <Leader>gd :Gdiff<cr>
nm <Leader>gD :diffoff!<cr><c-w>h:bd<cr>
nm <Leader>ge :Gedit<cr>
nm <Leader>gb :Gblame<cr>
nm <Leader>gl :Glog<cr>
nm <Leader>gv :Gitv<cr>
vm <leader>gv :Gitv!<cr>
nm <Leader>gV :Gitv!<cr>
nm <Leader>gh :Gitv -S
nm <Leader>gS :call Gitv_OpenGitCommand("diff", 'vnew')<cr>
" Cierra los buffers de fugitive automáticamente.
autocmd BufReadPost fugitive://* set bufhidden=delete
set tags^=.git/tags

" ##### INTEGRACIÓN CON TMUX #####
" Simplifica localizar el directorio del fichero actual.
cnoremap %% <C-r>=expand('%:h').'/'<CR>
cnoremap %<Tab> <C-r>=expand('%:p')<CR>

nm <Leader>sc :SlimuxShellRun
nm <Leader>sr :SlimuxREPLSendLine<CR>
vm <Leader>sr :SlimuxREPLSendSelection<CR>

" Ejecutar tests
let test#strategy = "slimux"
let test#preserve_screen = 1
let test#ruby#bundle_exec = 0
let test#ruby#use_binstubs = 0
nmap <Leader>sl :TestNearest<CR>
nmap <Leader>ss :TestFile<CR>
nmap <Leader>sp :TestLast<CR>
nmap <Leader>sv :TestVisit<CR>

" ###### AUTOCOMPLETADO ######
" Con la opción por defecto, los mensajes de diagnóstico dan problemas
set updatetime=300
" Fuera mensaje de |ins-completion-menu|
set shortmess+=c

" Mismos atajos que en la línea de órdenes
inoremap <silent><expr> <C-j> pumvisible() ? "\<C-n>" : coc#refresh()
inoremap <C-k> <C-p>

" Tabulador saca menú, navega por él, completa snippets, o indenta, dependiendo del contexto
inoremap <silent><expr> <tab>
  \ pumvisible() ? "\<C-n>" :
  \ coc#expandableOrJumpable() ? "\<C-r>=coc#rpc#request('doKeymap', ['snippets-expand-jump',''])\<CR>" :
  \ <SID>check_back_space() ? "\<tab>" :
  \ coc#refresh()
function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Tabulador para pasar de un lugar clave de snippet a otro
let g:coc_snippet_next = "<tab>"

" Ir a la definición (AltGr+D)
nmap \ <Plug>(coc-definition)
" Usos de la palabra actual
nm <Leader>re <Plug>(coc-references)
" Refactorizaciones
nm <Leader>rn <Plug>(coc-rename)
nm <Leader>rf <Plug>(coc-refactor)

" ###### OTROS PLUGINS ######
" Tabularize
" (requiere tabular, pero si pongo esta condición, no funciona)
nm <Leader>t> :Tabularize /=><CR>
vm <Leader>t> :Tabularize /=><CR>
nm <Leader>t: :Tabularize /:\zs<CR>
vm <Leader>t: :Tabularize /:\zs<CR>
nm <Leader>t, :Tabularize /,\zs<CR>
vm <Leader>t, :Tabularize /,\zs<CR>

" Surround con ERB
autocmd FileType eruby let b:surround_45 = "<% \r %>" " 45 es el ASCII de -
autocmd FileType eruby let b:surround_61 = "<%= \r %>" " 61 es el ASCII de =

" Tcomment
nm <Leader>c gcc
vm <Leader>c gc

" Syntastic
let g:syntastic_auto_loc_list = 1 " Abre automáticamente la lista de errores.
let g:syntastic_javascript_checkers = ["eslint"]
let g:syntastic_javascript_eslint_exe = "eslint --quiet"

" Undotree
nm <Leader>u :UndotreeToggle<CR>

" FZF
nnoremap <Leader>f :<C-u>FZF<CR>
nnoremap <Leader>h :History:<CR>

" Smartwords
nmap w  <Plug>(smartword-w)
nmap b  <Plug>(smartword-b)
nmap e  <Plug>(smartword-e)
nmap ge <Plug>(smartword-ge)
vmap w  <Plug>(smartword-w)
vmap b  <Plug>(smartword-b)
vmap e  <Plug>(smartword-e)
vmap ge <Plug>(smartword-ge)

" Búsquedas en ficheros
let g:grepper = {}
let g:grepper.tools = ["rg"]
let g:grepper.highlight = 1
let g:grepper.stop = 50000
let g:grepper.rg = { "grepprg": "rg --vimgrep --hidden -S" }
nmap <Leader>a :GrepperRg<space>

" Búsqueda del texto seleccionado
nmap gs <plug>(GrepperOperator)
vmap gs <plug>(GrepperOperator)

" Switch
let g:switch_mapping = "-"

" Targets
let g:targets_separators = ', . ; : + - = ~ _ * # | \ & $'
let g:targets_pairs = '() {} [] <>'

" ####### VARIOS #######
" Firma con la canción que se está escuchando
nm <Leader>k G:r!nowplaying<cr>O--<Esc>0k

" Repetir la última orden
nm <Leader>ñ @:

" Insetar punto de ruptura en Ruby
autocmd FileType eruby nm <buffer> <Leader>p O<% binding.pry %><Esc>
autocmd FileType ruby nm <buffer> <Leader>p Obinding.pry<Esc>

" Identificar espacios al final de la línea
autocmd BufWinEnter * match TrailingWhitespace /\s\+$/
autocmd InsertEnter * match TrailingWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match TrailingWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()
autocmd BufEnter,WinEnter * call matchadd("InvalidTab", "\\t", -1)

" Configuración local
let fichero_configuracion_local='~/.vimrc.local'
if filereadable(expand(fichero_configuracion_local))
  exec 'source ' . fichero_configuracion_local
endif

" Carga en 'arglist' los ficheros de la 'quickfix list'
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
function! QuickfixFilenames()
  " Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction
