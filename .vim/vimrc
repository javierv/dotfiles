" Quita el modo compatible con vi
set nocompatible

" ######## PLUGINS ########
packadd minpac
call minpac#init()
command! Pack call minpac#update()

" Edición de texto.
call minpac#add("tpope/vim-repeat")
call minpac#add("tpope/vim-surround")
call minpac#add("godlygeek/tabular")
call minpac#add("tpope/vim-unimpaired")
call minpac#add("inkarkat/vim-ReplaceWithRegister")
call minpac#add("tommcdo/vim-exchange")

" Navegación por conjuntos de texto.
call minpac#add("kana/vim-textobj-user")
call minpac#add("kana/vim-textobj-lastpat")
call minpac#add("kana/vim-textobj-indent")
call minpac#add("kana/vim-textobj-entire")
call minpac#add("kana/vim-textobj-line")
call minpac#add("wellle/targets.vim")
call minpac#add("kana/vim-smartword")
call minpac#add("nelstrom/vim-visual-star-search")

" Ruby.
call minpac#add("vim-ruby/vim-ruby")
call minpac#add("tpope/vim-projectionist")
call minpac#add("tpope/vim-rake")
call minpac#add("tpope/vim-bundler")
call minpac#add("tpope/vim-rails")
call minpac#add("tpope/vim-endwise")
call minpac#add("nelstrom/vim-textobj-rubyblock")

" Git.
call minpac#add("rbong/vim-flog")
call minpac#add("tpope/vim-fugitive")

" Otros lenguages.
call minpac#add("thomd/vim-jasmine")
call minpac#add("elixir-editors/vim-elixir")

" Apoyo a varios lenguajes.
call minpac#add("tpope/vim-commentary")
call minpac#add("scrooloose/syntastic")
call minpac#add("AndrewRadev/splitjoin.vim")
call minpac#add("AndrewRadev/switch.vim")

" Integración con la shell
call minpac#add("mhinz/vim-grepper")
call minpac#add("epeli/slimux")
call minpac#add("junegunn/fzf")
call minpac#add("junegunn/fzf.vim")
call minpac#add("janko/vim-test")

" Aspecto.
call minpac#add("Lokaltog/vim-powerline")
call minpac#add("junegunn/goyo.vim")

" Sustituciones.
call minpac#add("tpope/vim-abolish")

" Autocompletado
call minpac#add("neoclide/coc.nvim", { "branch": "release"})

" Varios.
call minpac#add("mbbill/undotree")
call minpac#add("moll/vim-bbye")

" Aumenta el poder del % para if-else-end y más cosas (activa por defecto).
runtime macros/matchit.vim


" ######## ENTORNO ########
set shell=/bin/zsh

" Muerte a los números octales.
set nrformats=hex

" La tecla leader por defecto es la \, que está muy lejos.
let mapleader = "\<Space>"

" Por defecto sólo se recuerdan las últimas 20 órdenes. Subimos.
set history=10000

" Conserva historial de cambios al salir
set undofile
set undodir=~/.vim/undo
augroup vimrc
  autocmd!
  autocmd BufWritePre /tmp/* setlocal noundofile
augroup END

" No expandir a la primera coincidencia de orden automáticamente al dar
" al tabulador, sino listar las posibles
" las opciones que más me gustan son list:longest y list:full
set wildmode=list:longest,full

" ###### ASPECTO ######
if has("gui_running")
  " Elimina las barras de edición y los menús
  set guioptions-=m
  set guioptions-=T
  " Quita el parpadeo del cursor.
  set guicursor+=a:blinkon0
endif

" Tema propio, basado en nuvola.
colorscheme autumnriver

" Resaltados de sintaxis en función del tipo de fichero
syntax on
filetype off
filetype plugin indent on

augroup usespaces
  autocmd!
  " Sintaxis con espacios
  autocmd FileType * setlocal ts=2 sts=2 sw=2 tw=0 expandtab

  " Mensajes de git con límite a 72 caracteres
  autocmd FileType gitcommit set tw=72
  autocmd FileType gitcommit nnoremap <buffer> == gqap

  " Resaltado de espacios a fin de línea y tabuladores
  set list listchars=trail:^,tab:^^
  autocmd Filetype help setlocal nolist
  " No mostrar espacios al final de la línea mientras se escribe
  autocmd InsertEnter * setlocal nolist
  autocmd InsertLeave * setlocal list
augroup END


" Incluye el título en la ventana (gvim lo hace automáticamente)
set title
" Incluye siempre la ruta del fichero que se edita
set laststatus=2

" Cambiar el cursor en Konsole, con o sin tmux.
if exists('$TMUX')
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\007\<Esc>\\"
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\007\<Esc>\\"
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" Powerline
set noshowmode
let g:Powerline_stl_path_style = "short"
" Requiere parchear una tipografía con powerline fontpatcher
let g:Powerline_symbols = "fancy"

" Muestra el número de línea
set number
" Muestra el número de línea al final de la pantalla (ya estaba activo por
" defecto)
set ruler
" Por defecto, no contrae las líneas cuando carga un nuevo buffer
set nofoldenable

" ####### COPIAR Y PEGAR ######
" Pegar a y del sistema
nmap Y "+y
nmap YY "+yy
vmap <C-c> "+y
nmap <C-p> "+gp
inoremap <C-r> <C-r><C-p>
" Pegar texto copiado en la línea de órdenes
cmap <C-v> <C-r>"
imap <C-v> <C-r>"

" Seleccionar el último texto copiado o pegado
nmap gV `[v`]


" ###### PASAR DE UN MODO A OTRO ######
" Pasar más fácilmente a la línea de órdenes
nnoremap , :
" Salir con la ñ de modo visual.
vmap ñ <C-c>
" Y lo mismo en la línea de órdenes
cmap ñ <C-c>
" C-c genera InsertLeave
inoremap <C-c> <Esc>

" ###### ABRIR, CERRAR Y GUARDAR ######
" Grabar archivo tanto en modo normal como en edición
nmap s :w<cr>
imap <C-s> <Esc>:w<cr>a
" Salir del buffer actual, dejando la ventana
nmap <Leader>d :Bdelete<cr>
" Cierra la ventana.
nnoremap - q
nmap q :q<cr>
"Dejar sólo el buffer actual
nmap <Leader>o :on<cr>
" Abrir ficheros
nmap <Leader>v :vsplit<cr>
"
" Recupera la línea del fichero en la que estaba la última vez que se editó
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
" Permite quitar el buffer de la ventana aunque no se haya grabado
set hidden
" Directorios donde se guardan todos los archivos swp y backups
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp

" Cerrar quickfix y loclist
nmap <Leader>c :lclose<cr>:cclose<cr>

" ###### NAVEGACIÓN ######
" Navegación por líneas.
" 0 es más fácil de teclear que ^ en teclado español, así que intercambio sus
" funciones
nnoremap 0 ^
nnoremap ^ 0
vnoremap 0 ^
vnoremap ^ 0

" Ir a marcas
" ` es más útil que ' porque te lleva también a la columna, no sólo a la línea
nnoremap ñ `

" Navegación entre ventanas
nnoremap <tab> <C-w>w
" Abrir ventanas a la derecha en vez de a la izquierda
" y abajo en vez de arriba
set splitright
set splitbelow
" Navegación entre buffers
nmap <C-n> ]b
" Editar el buffer que se editaba justo antes de cambiar al actual
nmap <Leader><Leader> <C-^>
" Anterior y siguiente de quickfix y loclist
function! PrevInList()
  if get(getloclist(0, {'winid':0}), 'winid', 0)
    exec "normal [l"
  elseif len(getqflist())
    exec "normal [q"
  else
    exec "normal! ("
  endif
endfunction
function! NextInList()
  if get(getloclist(0, {'winid':0}), 'winid', 0)
    exec "normal ]l"
  elseif len(getqflist())
    exec "normal ]q"
  else
    exec "normal! )"
  endif
endfunction
nmap ( :call PrevInList()<cr>
nmap ) :call NextInList()<cr>

" Saltos
" Vim no distinque entre Ctrl-i y TAB, y uso tab para cambiar de ventana
nnoremap <C-l> <C-i>

" C-] en algunos terminales se interpreta como C-+ y además es difícil de
" teclear. _ es <S-space>, que no se se puede asignar directamente.
nmap _ <C-]>

" Si el nombre del fichero incluye número de línea, vamos a esa línea con gf
set isfname-=:
nnoremap gf gF
nnoremap gF gf

" Saltar por historial de cambios
nnoremap U g;

" ###### BÚSQUEDAS ######
" Resalta el primer resultado de la búsqueda según tecleas
set incsearch
" Resalta todas las coincidencias de la búsqueda
set hlsearch
" Quita el resaltado de las coincidencias (lo vuelve a poner en la siguiente
" búsqueda)
nmap + :nohlsearch<cr>
" No diferencia buscar mayúsculas y minúsculas salvo que se escriba alguna
" mayúscula set ignorecase
set ignorecase
set smartcase
" Busca literal por defecto.
nnoremap / /\V

" ##### SUSTITUCIONES #####
" Repetir la última sustutición conserva los modificadores (:help &)
nnoremap & :&&<cr>
vnoremap & :&&<cr>


" ##### LÍNEA DE ÓRDENES #####
" Buscar el historial de forma incremental sin las flechas
cnoremap <C-k> <Up>
cnoremap <C-j> <Down>

" Atajos de readline
cnoremap <C-a> <Home>
cnoremap <C-b> <Left>

" #### INTRODUCIR CARACTERES Y LÍNEAS EN MODO NORMAL ####
" Introducir un carácter antes/después del cursor y volver a modo normal
function! RepeatChar(char, count)
  return repeat(a:char, a:count)
endfunction
nm <bs> :<C-u>exec "normal i".RepeatChar(nr2char(getchar()), v:count1)<CR>

" Introducir líneas en blanco antes y después de la actual en modo normal
nmap <C-k> [<Space>
nmap <C-j> ]<Space>
" Subir y bajar la línea actual
nmap <leader>k [e
nmap <leader>j ]e

" o y O no añaden comentario cuando se usan en línea con comentario
autocmd FileType * setlocal formatoptions-=o


" ######### RAILS #########
nmap <Leader>em :Emodel<Space>
nmap <Leader>ec :Econtroller<Space>
nmap <Leader>ev :Eview<Space>
nmap <Leader>eh :Ehelper<Space>
nmap <Leader>ej :Ejavascript<Space>
nmap <Leader>ed :Edecorator<Space>
nmap <Leader>ep :Epdf<Space>
nmap <Leader>ea :A<cr>
nmap <Leader>er :R<cr>
nmap <Leader>el :Elib<Space>
nmap <Leader>es :Espec<Space>
nmap <Leader>esm :Espec models/
nmap <Leader>esf :Espec features/
nmap <Leader>ess :Espec system/
nmap <Leader>esl :Espec lib/
nmap <Leader>esc :Espec controllers/
nmap <Leader>esv :Espec views/
nmap <Leader>ef :Efactory<Space>
nmap <Leader>ee :Eenvironment<Space>
nmap <Leader>ei :Einitializer<Space>
nmap <Leader>et :Elocale<Space>
" Atajos para tipos de ficheros.
let g:rails_projections = {
  \ "app/decorators/*_decorator.rb": { "command": "decorator" },
  \ "app/form_builders/*_form_builder.rb": { "command": "builder" },
  \ "app/pdfs/*.rb": { "command": "pdf" },
  \ "app/cells/*_cell.rb": { "command": "cell" },
  \ "app/cells/*.haml": { "command": "cview" },
  \ "spec/javascripts/fixtures/*.html": { "command": "jfixtures" },
  \ "spec/factories/*.rb": {"command": "factory"},
  \ "spec/requests/support/*.rb": {"command": "support"}}

" Bundler
nmap <Leader>b :Bopen<Space>

" ######## GIT ########
" atajos para Git
nmap gs :tab Gstatus<cr>
nmap gc :Gcommit<cr>
nmap ga :Gcommit --amend<cr>
nmap gw :Gwrite<cr>
nmap gr :Gread<cr>
nmap gd :Gdiff<cr>
nmap gD :diffoff!<cr><c-w>h:bd<cr>
nmap ge :Gedit<cr>
nmap gb :Gblame<cr>
nmap gl :Flogsplit -path=%<cr>
vmap gl :Flogsplit<cr>
nmap gv :Flog<cr>
nmap gh :Flog -patch-search=
nmap gS :call Gitv_OpenGitCommand("diff", "tabedit")<cr>
" Cierra los buffers de fugitive automáticamente.
autocmd BufReadPost fugitive://* set bufhidden=delete
set tags^=.git/tags
autocmd FileType floggraph nmap <buffer> q gq

" ##### INTEGRACIÓN CON TMUX #####
" Simplifica localizar el directorio del fichero actual.
cnoremap %% <C-r>=expand('%:h').'/'<cr>
cnoremap %<Tab> <C-r>=expand('%:p')<cr>

nmap <Leader>sc :SlimuxShellRun<space>
nmap <Leader>sr :SlimuxREPLSendLine<cr>
vmap <Leader>sr :SlimuxREPLSendSelection<cr>

" Ejecutar tests
let test#strategy = "slimux"
let test#preserve_screen = 1
let test#ruby#bundle_exec = 0
let test#ruby#use_binstubs = 0
nmap <Leader>sl :TestNearest<cr>
nmap <Leader>ss :TestFile<cr>
nmap <Leader>sp :TestLast<cr>
nmap <Leader>sv :TestVisit<cr>

" ###### AUTOCOMPLETADO ######
" Con la opción por defecto, los mensajes de diagnóstico dan problemas
set updatetime=300
" Fuera mensaje de |ins-completion-menu|
set shortmess+=c

" Mismos atajos que en la línea de órdenes
inoremap <silent><expr> <C-j> pumvisible() ? "\<C-n>" : coc#refresh()
inoremap <C-k> <C-p>

" Tabulador saca menú, navega por él, completa snippets, o indenta, dependiendo del contexto
inoremap <silent><expr> <tab>
  \ pumvisible() ? "\<C-n>" :
  \ coc#expandableOrJumpable() ? "\<C-r>=coc#rpc#request('doKeymap', ['snippets-expand-jump',''])\<cr>" :
  \ <SID>check_back_space() ? "\<tab>" :
  \ coc#refresh()
function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Tabulador para pasar de un lugar clave de snippet a otro
let g:coc_snippet_next = "<tab>"

" Ir a la definición (<C-space>, que no se puede asignar directamente)
nmap <nul> <Plug>(coc-definition)
" Usos de la palabra actual
nmap <Leader>re <Plug>(coc-references)
" Refactorizaciones
nmap <Leader>rn <Plug>(coc-rename)
nmap <Leader>rf <Plug>(coc-refactor)

" ###### OTROS PLUGINS ######
" Tabularize
" (requiere tabular, pero si pongo esta condición, no funciona)
nmap <Leader>t> :Tabularize /=><cr>
vmap <Leader>t> :Tabularize /=><cr>
nmap <Leader>t: :Tabularize /:\zs<cr>
vmap <Leader>t: :Tabularize /:\zs<cr>
nmap <Leader>t, :Tabularize /,\zs<cr>
vmap <Leader>t, :Tabularize /,\zs<cr>

" Surround con ERB
autocmd FileType eruby let b:surround_45 = "<% \r %>" " 45 es el ASCII de -
autocmd FileType eruby let b:surround_61 = "<%= \r %>" " 61 es el ASCII de =

" Comentar código
nmap <Leader>m <Plug>CommentaryLine
vmap <Leader>m <Plug>Commentary
nmap gm <Plug>Commentary
" Sobreescribo mapas por defecto, aunque no los uso
nmap gmu <Plug>Commentary<Plug>Commentary
nmap gmm <Plug>CommentaryLine

" Reemplazar registro
nmap R <Plug>ReplaceWithRegisterOperator
vmap R <Plug>ReplaceWithRegisterVisual
" Evito que se use el atajo original, aunque esto no lo use
nmap RR <Plug>ReplaceWithRegisterLine

" Syntastic
let g:syntastic_auto_loc_list = 1 " Abre automáticamente la lista de errores.
let g:syntastic_javascript_checkers = ["eslint"]
let g:syntastic_javascript_eslint_exe = "eslint --quiet"

" Undotree
nmap <leader>u :UndotreeToggle<cr>

" FZF
nnoremap <Leader>f :<C-u>FZF<cr>
nnoremap <Leader>h :History:<cr>
nnoremap <Leader>l :Tags<cr>

" Smartwords
nmap w <Plug>(smartword-w)
nmap b <Plug>(smartword-b)
nmap e <Plug>(smartword-e)
nmap é <Plug>(smartword-ge)
vmap w <Plug>(smartword-w)
vmap b <Plug>(smartword-b)
vmap e <Plug>(smartword-e)
vmap é <Plug>(smartword-ge)

" Búsquedas en ficheros
let g:grepper = {}
let g:grepper.tools = ["rg"]
let g:grepper.highlight = 1
let g:grepper.stop = 50000
let g:grepper.rg = { "grepprg": "rg --vimgrep --hidden -S" }
nmap <Leader>a :GrepperRg<space>

" Búsqueda del texto seleccionado
nmap K <plug>(GrepperOperator)
nmap KK Kiw
vmap K <plug>(GrepperOperator)

" Splitjoin
let g:splitjoin_join_mapping = "J"
let g:splitjoin_split_mapping = "r\<cr>"
nmap S r<cr>

" Switch
let g:switch_mapping = "\<leader>w"

" Targets
let g:targets_separators = ', . ; : + - = ~ _ * # | \ & $'
let g:targets_pairs = '() {} [] <>'

" ####### PROGRAMACIÓN #######
autocmd Filetype ruby,javascript call SetProgrammingOptions()
function SetProgrammingOptions()
  " Navegación por métodos
  nmap <buffer> { [m
  nmap <buffer> } ]m

  " Autoindentado al pegar
  nnoremap <silent> <Plug>PasteIndent p=`]<C-o> :call repeat#set("\<Plug>PasteIndent", v:count)<cr>
  nnoremap <silent> <Plug>PasteAbove P=`]<C-o> :call repeat#set("\<Plug>PasteAbove")<cr>
  nmap <buffer> p <Plug>PasteIndent
  nmap <buffer> P <Plug>PasteAbove
endfunction

" Insertar punto de ruptura
autocmd FileType eruby nmap <buffer> <Leader>p O<% binding.pry %><Esc>
autocmd FileType ruby nmap <buffer> <Leader>p Obinding.pry<Esc>

" ####### VARIOS #######
" Firma con la canción que se está escuchando
nmap <Leader>p G:r!nowplaying<cr>O--<Esc>0k

" Configuración local
let fichero_configuracion_local='~/.vimrc.local'
if filereadable(expand(fichero_configuracion_local))
  exec 'source ' . fichero_configuracion_local
endif

" Carga en 'arglist' los ficheros de la 'quickfix list'
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
function! QuickfixFilenames()
  " Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction
